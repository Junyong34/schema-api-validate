/* tslint:disable */
/* eslint-disable */
/**
 * Turbine2.0 API Server
 * Turbine API Document
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddUser
 */
export interface AddUser {
    /**
     * 사용자 아이디
     * @type {number}
     * @memberof AddUser
     */
    'id': number;
    /**
     * 사용자 로그인 아이디
     * @type {string}
     * @memberof AddUser
     */
    'userId': string;
    /**
     * 사용자명
     * @type {string}
     * @memberof AddUser
     */
    'userName': string;
    /**
     * 회사명
     * @type {string}
     * @memberof AddUser
     */
    'companyName': string;
    /**
     * 부서명
     * @type {string}
     * @memberof AddUser
     */
    'teamName': string;
    /**
     * 핸드폰 번호
     * @type {string}
     * @memberof AddUser
     */
    'phoneNum': string;
    /**
     * 이메일
     * @type {string}
     * @memberof AddUser
     */
    'email': string;
    /**
     * 등록일자
     * @type {string}
     * @memberof AddUser
     */
    'registerDate': string;
    /**
     * 계약만료일
     * @type {string}
     * @memberof AddUser
     */
    'contractDueDate': string;
    /**
     * 사용자 권한
     * @type {string}
     * @memberof AddUser
     */
    'authority': string;
    /**
     * 사용자 비밀번호
     * @type {string}
     * @memberof AddUser
     */
    'userPassword': string;
}
/**
 * 
 * @export
 * @interface AddUserAllOf
 */
export interface AddUserAllOf {
    /**
     * 사용자 비밀번호
     * @type {string}
     * @memberof AddUserAllOf
     */
    'userPassword': string;
}
/**
 * 
 * @export
 * @interface BearingBodePolarData
 */
export interface BearingBodePolarData {
    /**
     * journal 베어링 아이디
     * @type {number}
     * @memberof BearingBodePolarData
     */
    'bearingId': number;
    /**
     * journal 베어링 아이디
     * @type {string}
     * @memberof BearingBodePolarData
     */
    'bearingName': string;
    /**
     * phase data([크기 (r), x phase값 (theta)])
     * @type {Array<object>}
     * @memberof BearingBodePolarData
     */
    'vibVectorX': Array<object>;
    /**
     * ([크기 (r), x phase값 (theta)])
     * @type {Array<object>}
     * @memberof BearingBodePolarData
     */
    'vibVectorY': Array<object>;
    /**
     * RPM 값, 진동값 한 주기 측정시 RPM 값
     * @type {number}
     * @memberof BearingBodePolarData
     */
    'rpm': number;
}
/**
 * 
 * @export
 * @interface BearingFftData
 */
export interface BearingFftData {
    /**
     * journal 베어링 아이디
     * @type {number}
     * @memberof BearingFftData
     */
    'bearingId': number;
    /**
     * journal 베어링 아이디
     * @type {string}
     * @memberof BearingFftData
     */
    'bearingName': string;
    /**
     * x축 fft data
     * @type {DataFftPoint}
     * @memberof BearingFftData
     */
    'vibXFft': DataFftPoint;
    /**
     * y축 fft data
     * @type {DataFftPoint}
     * @memberof BearingFftData
     */
    'vibYFft': DataFftPoint;
    /**
     * FFT full spectrum data
     * @type {DataFftPoint}
     * @memberof BearingFftData
     */
    'vibFftFull': DataFftPoint;
}
/**
 * 
 * @export
 * @interface BearingOrbitData
 */
export interface BearingOrbitData {
    /**
     * journal 베어링 아이디
     * @type {number}
     * @memberof BearingOrbitData
     */
    'bearingId': number;
    /**
     * journal 베어링 아이디
     * @type {string}
     * @memberof BearingOrbitData
     */
    'bearingName': string;
    /**
     * 계측 시간 값
     * @type {Array<number>}
     * @memberof BearingOrbitData
     */
    'times': Array<number>;
    /**
     * x,y축 통합 orbit data
     * @type {Array<object>}
     * @memberof BearingOrbitData
     */
    'vibOrbitRaw': Array<object>;
    /**
     * x, y축 orbit 1x data
     * @type {Array<object>}
     * @memberof BearingOrbitData
     */
    'vibOrbit1X': Array<object>;
}
/**
 * 
 * @export
 * @interface BearingP2pData
 */
export interface BearingP2pData {
    /**
     * journal 베어링 아이디
     * @type {number}
     * @memberof BearingP2pData
     */
    'bearingId': number;
    /**
     * journal 베어링 아이디
     * @type {string}
     * @memberof BearingP2pData
     */
    'bearingName': string;
    /**
     * 베어링 X축 p2p 데이터
     * @type {Array<object>}
     * @memberof BearingP2pData
     */
    'vibXP2p': Array<object>;
    /**
     * 베어링 Y축 p2p 데이터
     * @type {Array<object>}
     * @memberof BearingP2pData
     */
    'vibYP2p': Array<object>;
}
/**
 * 
 * @export
 * @interface BearingShaftCenterlineData
 */
export interface BearingShaftCenterlineData {
    /**
     * journal 베어링 아이디
     * @type {number}
     * @memberof BearingShaftCenterlineData
     */
    'bearingId': number;
    /**
     * journal 베어링 아이디
     * @type {string}
     * @memberof BearingShaftCenterlineData
     */
    'bearingName': string;
    /**
     * x, y축 shaft center line data
     * @type {Array<object>}
     * @memberof BearingShaftCenterlineData
     */
    'shaftCenter': Array<object>;
    /**
     * shaft center rpm 데이터
     * @type {number}
     * @memberof BearingShaftCenterlineData
     */
    'rpm': number;
}
/**
 * 
 * @export
 * @interface ChangePassword
 */
export interface ChangePassword {
    /**
     * 사용자 아이디
     * @type {string}
     * @memberof ChangePassword
     */
    'id': string;
    /**
     * 변경 전 비밀번호
     * @type {string}
     * @memberof ChangePassword
     */
    'before_changed_password': string;
    /**
     * 변경 후 비밀번호
     * @type {string}
     * @memberof ChangePassword
     */
    'after_changed_password': string;
}
/**
 * 
 * @export
 * @interface CreateBody
 */
export interface CreateBody {
    /**
     * 점검일지 제목
     * @type {string}
     * @memberof CreateBody
     */
    'title': string;
    /**
     * 작성자
     * @type {string}
     * @memberof CreateBody
     */
    'inspector': string;
    /**
     * 점검일자
     * @type {string}
     * @memberof CreateBody
     */
    'inspectionTime': string;
    /**
     * 상세 진단 내용
     * @type {string}
     * @memberof CreateBody
     */
    'inspectionDetail': string;
    /**
     * 조치 내용
     * @type {string}
     * @memberof CreateBody
     */
    'actionDetail': string;
    /**
     * 터빈 아이디
     * @type {number}
     * @memberof CreateBody
     */
    'turbineId': number;
    /**
     * 터빈 고장 이벤트 아이디
     * @type {number}
     * @memberof CreateBody
     */
    'turbineFailureId': number;
}
/**
 * 
 * @export
 * @interface CreateBodyAllOf
 */
export interface CreateBodyAllOf {
    /**
     * 터빈 아이디
     * @type {number}
     * @memberof CreateBodyAllOf
     */
    'turbineId': number;
    /**
     * 터빈 고장 이벤트 아이디
     * @type {number}
     * @memberof CreateBodyAllOf
     */
    'turbineFailureId': number;
}
/**
 * 
 * @export
 * @interface DashboardBearing
 */
export interface DashboardBearing {
    /**
     * 
     * @type {Array<JournalBearingInfo>}
     * @memberof DashboardBearing
     */
    'journalBearing'?: Array<JournalBearingInfo>;
    /**
     * 
     * @type {Array<ThrustBearingInfo>}
     * @memberof DashboardBearing
     */
    'thrustBearing'?: Array<ThrustBearingInfo>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DashboardBearing
     */
    'turbineFailureMode'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DashboardDiagnosis
 */
export interface DashboardDiagnosis {
    /**
     * 
     * @type {Array<DashboardFailure>}
     * @memberof DashboardDiagnosis
     */
    'turbineFailures'?: Array<DashboardFailure>;
}
/**
 * 
 * @export
 * @interface DashboardFailure
 */
export interface DashboardFailure {
    /**
     * 베어링 아이디
     * @type {number}
     * @memberof DashboardFailure
     */
    'id': number;
    /**
     * 베어링 이름
     * @type {string}
     * @memberof DashboardFailure
     */
    'bearingName': string;
    /**
     * 베어링 진단 상태(normal/warning/trip)
     * @type {string}
     * @memberof DashboardFailure
     */
    'state': string;
    /**
     * 베어링 고장내용
     * @type {string}
     * @memberof DashboardFailure
     */
    'failureDetail': string;
    /**
     * 진단시점
     * @type {string}
     * @memberof DashboardFailure
     */
    'failureTime': string;
}
/**
 * 
 * @export
 * @interface DataFftPoint
 */
export interface DataFftPoint {
    /**
     * graph x 값
     * @type {Array<number>}
     * @memberof DataFftPoint
     */
    'x'?: Array<number>;
    /**
     * graph x 값
     * @type {Array<number>}
     * @memberof DataFftPoint
     */
    'y'?: Array<number>;
}
/**
 * 
 * @export
 * @interface DataGraphBodePolar
 */
export interface DataGraphBodePolar {
    /**
     * 계측시점
     * @type {string}
     * @memberof DataGraphBodePolar
     */
    'acqTime': string;
    /**
     * 
     * @type {Array<BearingBodePolarData>}
     * @memberof DataGraphBodePolar
     */
    'bearings'?: Array<BearingBodePolarData>;
}
/**
 * 
 * @export
 * @interface DataGraphFft
 */
export interface DataGraphFft {
    /**
     * 계측시점
     * @type {string}
     * @memberof DataGraphFft
     */
    'acqTime': string;
    /**
     * 
     * @type {Array<BearingFftData>}
     * @memberof DataGraphFft
     */
    'bearings'?: Array<BearingFftData>;
}
/**
 * 
 * @export
 * @interface DataGraphOverviewOrbit
 */
export interface DataGraphOverviewOrbit {
    /**
     * 계측시점
     * @type {string}
     * @memberof DataGraphOverviewOrbit
     */
    'acqTime': string;
    /**
     * 
     * @type {Array<BearingOrbitData>}
     * @memberof DataGraphOverviewOrbit
     */
    'bearings'?: Array<BearingOrbitData>;
}
/**
 * 
 * @export
 * @interface DataGraphOverviewVibration
 */
export interface DataGraphOverviewVibration {
    /**
     * 
     * @type {Array<BearingP2pData>}
     * @memberof DataGraphOverviewVibration
     */
    'bearings'?: Array<BearingP2pData>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DataGraphOverviewVibration
     */
    'timestamps'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DataGraphShaftCenter
 */
export interface DataGraphShaftCenter {
    /**
     * 계측시점
     * @type {string}
     * @memberof DataGraphShaftCenter
     */
    'acqTime': string;
    /**
     * 
     * @type {Array<BearingShaftCenterlineData>}
     * @memberof DataGraphShaftCenter
     */
    'bearings'?: Array<BearingShaftCenterlineData>;
}
/**
 * 
 * @export
 * @interface DeleteSuccess
 */
export interface DeleteSuccess {
    /**
     * 응답 메시지
     * @type {string}
     * @memberof DeleteSuccess
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface FailureState
 */
export interface FailureState {
    /**
     * 해당 진단의 아이디
     * @type {number}
     * @memberof FailureState
     */
    'id': number;
    /**
     * 베어링 진단 상태(normal/warning/trip)
     * @type {number}
     * @memberof FailureState
     */
    'state': number;
    /**
     * 고장내용
     * @type {string}
     * @memberof FailureState
     */
    'failureDetail': string;
    /**
     * 발생시점
     * @type {string}
     * @memberof FailureState
     */
    'failureTime': string;
}
/**
 * 
 * @export
 * @interface GasGenerationInfo
 */
export interface GasGenerationInfo {
    /**
     * Gas turbine rpm
     * @type {number}
     * @memberof GasGenerationInfo
     */
    'gasRpm': number;
    /**
     * Gas turbine 출력량
     * @type {number}
     * @memberof GasGenerationInfo
     */
    'gasOutput': number;
    /**
     * Gas turbine 열 생산량
     * @type {number}
     * @memberof GasGenerationInfo
     */
    'gasHeat': number;
}
/**
 * 
 * @export
 * @interface HealthCheck
 */
export interface HealthCheck {
    /**
     * health check
     * @type {boolean}
     * @memberof HealthCheck
     */
    'healthCheck'?: boolean;
}
/**
 * 
 * @export
 * @interface InputLogin
 */
export interface InputLogin {
    /**
     * 사용자 아이디
     * @type {string}
     * @memberof InputLogin
     */
    'id': string;
    /**
     * 사용자 비밀번호
     * @type {string}
     * @memberof InputLogin
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface InspectionInfo
 */
export interface InspectionInfo {
    /**
     * 점검일지 아이디
     * @type {number}
     * @memberof InspectionInfo
     */
    'id': number;
    /**
     * 터빈 아이디
     * @type {number}
     * @memberof InspectionInfo
     */
    'turbineId': number;
    /**
     * 터빈 고장 이벤트 ID
     * @type {number}
     * @memberof InspectionInfo
     */
    'turbineFailureId': number;
    /**
     * 진단대상
     * @type {string}
     * @memberof InspectionInfo
     */
    'diagnosisTarget': string;
    /**
     * 점검일자
     * @type {string}
     * @memberof InspectionInfo
     */
    'inspectionTime': string;
    /**
     * 작성자
     * @type {string}
     * @memberof InspectionInfo
     */
    'inspector': string;
    /**
     * 제목
     * @type {string}
     * @memberof InspectionInfo
     */
    'title': string;
    /**
     * 진단내용
     * @type {string}
     * @memberof InspectionInfo
     */
    'inspectionDetail': string;
    /**
     * 조치내용
     * @type {string}
     * @memberof InspectionInfo
     */
    'actionDetail': string;
}
/**
 * 
 * @export
 * @interface JournalBearingInfo
 */
export interface JournalBearingInfo {
    /**
     * journal 베어링 아이디
     * @type {number}
     * @memberof JournalBearingInfo
     */
    'bearingId': number;
    /**
     * 베어링 이름
     * @type {string}
     * @memberof JournalBearingInfo
     */
    'bearingName': string;
    /**
     * x축 peak to peak
     * @type {number}
     * @memberof JournalBearingInfo
     */
    'vibXP2p': number;
    /**
     * y축 peak to peak
     * @type {number}
     * @memberof JournalBearingInfo
     */
    'vibYP2p': number;
    /**
     * x축 phase
     * @type {number}
     * @memberof JournalBearingInfo
     */
    'vibXPhase': number;
    /**
     * y축 phase
     * @type {number}
     * @memberof JournalBearingInfo
     */
    'vibYPhase': number;
    /**
     * 베어링 온도
     * @type {number}
     * @memberof JournalBearingInfo
     */
    'temperature': number;
}
/**
 * 
 * @export
 * @interface OrbitThreshold
 */
export interface OrbitThreshold {
    /**
     * 중심점 X
     * @type {number}
     * @memberof OrbitThreshold
     */
    'centerX': number;
    /**
     * 중심점 Y
     * @type {number}
     * @memberof OrbitThreshold
     */
    'centerY': number;
    /**
     * 반지름 X
     * @type {number}
     * @memberof OrbitThreshold
     */
    'radiusX': number;
    /**
     * 반지름 Y
     * @type {number}
     * @memberof OrbitThreshold
     */
    'radiusY': number;
    /**
     * 회전 정도
     * @type {number}
     * @memberof OrbitThreshold
     */
    'rotationValue': number;
}
/**
 * 
 * @export
 * @interface OutputLogin
 */
export interface OutputLogin {
    /**
     * 인증 토큰
     * @type {string}
     * @memberof OutputLogin
     */
    'accessToken'?: string;
    /**
     * 관리자 여부
     * @type {boolean}
     * @memberof OutputLogin
     */
    'admin'?: boolean;
    /**
     * 팀 이름
     * @type {string}
     * @memberof OutputLogin
     */
    'teamName'?: string;
    /**
     * 전자우편
     * @type {string}
     * @memberof OutputLogin
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface ReportResp
 */
export interface ReportResp {
    /**
     * 베어링 아이디
     * @type {number}
     * @memberof ReportResp
     */
    'bearingId': number;
    /**
     * 베어링 이름
     * @type {string}
     * @memberof ReportResp
     */
    'bearingName': string;
    /**
     * 계측 시간
     * @type {string}
     * @memberof ReportResp
     */
    'acqTime': string;
    /**
     * RPM
     * @type {number}
     * @memberof ReportResp
     */
    'rpm': number;
    /**
     * 베어링 상태
     * @type {string}
     * @memberof ReportResp
     */
    'status': string;
    /**
     * 원인
     * @type {string}
     * @memberof ReportResp
     */
    'rootCause': string;
    /**
     * 주로 설비 정지 후 저속 회전상태에서 회전체 warm up
     * @type {string}
     * @memberof ReportResp
     */
    'recommended': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ReportResp
     */
    'processData': Array<string>;
    /**
     * FFT 관련 정보
     * @type {string}
     * @memberof ReportResp
     */
    'fft': string;
    /**
     * Phase 값
     * @type {string}
     * @memberof ReportResp
     */
    'phase': string;
    /**
     * 
     * @type {BearingOrbitData}
     * @memberof ReportResp
     */
    'orbit_raw'?: BearingOrbitData;
    /**
     * 
     * @type {BearingFftData}
     * @memberof ReportResp
     */
    'fft_raw': BearingFftData;
}
/**
 * 
 * @export
 * @interface ReportRest
 */
export interface ReportRest {
    /**
     * 
     * @type {ReportResp}
     * @memberof ReportRest
     */
    'report'?: ReportResp;
}
/**
 * 
 * @export
 * @interface ResolutionInfo
 */
export interface ResolutionInfo {
    /**
     * 해당 시간
     * @type {string}
     * @memberof ResolutionInfo
     */
    'acqTime': string;
    /**
     * 해결된 이슈
     * @type {number}
     * @memberof ResolutionInfo
     */
    'solvedCount': number;
    /**
     * 미해결된 이슈
     * @type {number}
     * @memberof ResolutionInfo
     */
    'unSolvedCount': number;
}
/**
 * 
 * @export
 * @interface SearchDataSlider
 */
export interface SearchDataSlider {
    /**
     * 
     * @type {number}
     * @memberof SearchDataSlider
     */
    'totalCount'?: number;
    /**
     * 
     * @type {SearchResult}
     * @memberof SearchDataSlider
     */
    'searchResult'?: SearchResult;
}
/**
 * 
 * @export
 * @interface SearchResult
 */
export interface SearchResult {
    /**
     * 
     * @type {number}
     * @memberof SearchResult
     */
    'page'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchResult
     */
    'acqTimes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SteamGenerationInfo
 */
export interface SteamGenerationInfo {
    /**
     * HP/IP turbine rpm
     * @type {number}
     * @memberof SteamGenerationInfo
     */
    'HipRpm': number;
    /**
     * LP turbine rpm
     * @type {number}
     * @memberof SteamGenerationInfo
     */
    'LpRpm': number;
    /**
     * steam turbine 출력량
     * @type {number}
     * @memberof SteamGenerationInfo
     */
    'steamOutput': number;
    /**
     * steam turbine 열 생산량
     * @type {number}
     * @memberof SteamGenerationInfo
     */
    'steamHeat': number;
}
/**
 * 
 * @export
 * @interface SystemEventList
 */
export interface SystemEventList {
    /**
     * 이벤트 아이디
     * @type {number}
     * @memberof SystemEventList
     */
    'id': number;
    /**
     * 터빈 아이디
     * @type {number}
     * @memberof SystemEventList
     */
    'turbineId': number;
    /**
     * 베어링 아이디
     * @type {number}
     * @memberof SystemEventList
     */
    'bearingId': number;
    /**
     * 진단대상(설비:터빈/위치:베어링)
     * @type {string}
     * @memberof SystemEventList
     */
    'diagnosisTarget': string;
    /**
     * 이벤트 시작 시간(고장 진단 시간)
     * @type {string}
     * @memberof SystemEventList
     */
    'startTime': string;
    /**
     * 베어링 진단 상태(normal/warning/trip)
     * @type {string}
     * @memberof SystemEventList
     */
    'state': string;
    /**
     * 이벤트 내용
     * @type {string}
     * @memberof SystemEventList
     */
    'failureDetail': string;
    /**
     * 진동 특성
     * @type {string}
     * @memberof SystemEventList
     */
    'vibrationChar': string;
    /**
     * 연관 태그명
     * @type {string}
     * @memberof SystemEventList
     */
    'relatedFactorName': string;
    /**
     * 이벤트 종료 시간
     * @type {string}
     * @memberof SystemEventList
     */
    'endTime': string;
    /**
     * 담당자
     * @type {string}
     * @memberof SystemEventList
     */
    'chargePerson': string;
    /**
     * 담당자 확인 여부
     * @type {boolean}
     * @memberof SystemEventList
     */
    'isChecked': boolean;
    /**
     * 점검일지 아이디
     * @type {number}
     * @memberof SystemEventList
     */
    'inspectionInfoId': number;
    /**
     * 점검일지 유/무
     * @type {boolean}
     * @memberof SystemEventList
     */
    'isInspected': boolean;
    /**
     * 자동보고서 아이디
     * @type {number}
     * @memberof SystemEventList
     */
    'autoReportId': number;
    /**
     * 자동보고서 해결내역(완료: True/미완료: False)
     * @type {boolean}
     * @memberof SystemEventList
     */
    'autoReportState': boolean;
}
/**
 * 
 * @export
 * @interface SystemEventObj
 */
export interface SystemEventObj {
    /**
     * 
     * @type {number}
     * @memberof SystemEventObj
     */
    'vibrationId'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemEventObj
     */
    'turbineId'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemEventObj
     */
    'bearingId'?: number;
    /**
     * 
     * @type {string}
     * @memberof SystemEventObj
     */
    'bearingInfo'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemEventObj
     */
    'acqTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof SystemEventObj
     */
    'iso'?: number;
    /**
     * 
     * @type {string}
     * @memberof SystemEventObj
     */
    'result'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemEventObj
     */
    'rootCause'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemEventObj
     */
    'recommended'?: string;
}
/**
 * 
 * @export
 * @interface SystemEventResp
 */
export interface SystemEventResp {
    /**
     * 
     * @type {Array<SystemEventObj>}
     * @memberof SystemEventResp
     */
    'systemEvents'?: Array<SystemEventObj>;
}
/**
 * 
 * @export
 * @interface SystemEventResult
 */
export interface SystemEventResult {
    /**
     * 
     * @type {number}
     * @memberof SystemEventResult
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemEventResult
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemEventResult
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<SystemEventList>}
     * @memberof SystemEventResult
     */
    'turbineFailures'?: Array<SystemEventList>;
}
/**
 * 
 * @export
 * @interface TagDataList
 */
export interface TagDataList {
    /**
     * 
     * @type {Array<TagDataNested>}
     * @memberof TagDataList
     */
    'tagData'?: Array<TagDataNested>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TagDataList
     */
    'timestamps'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TagDataNested
 */
export interface TagDataNested {
    /**
     * 
     * @type {string}
     * @memberof TagDataNested
     */
    'tagCode'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof TagDataNested
     */
    'tagValue'?: Array<number>;
}
/**
 * 
 * @export
 * @interface TagDescNested
 */
export interface TagDescNested {
    /**
     * 
     * @type {string}
     * @memberof TagDescNested
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof TagDescNested
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface TagList
 */
export interface TagList {
    /**
     * 
     * @type {Array<TagNested>}
     * @memberof TagList
     */
    'tags'?: Array<TagNested>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TagList
     */
    'recommendTags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TagNested
 */
export interface TagNested {
    /**
     * 
     * @type {string}
     * @memberof TagNested
     */
    'category'?: string;
    /**
     * 
     * @type {Array<TagDescNested>}
     * @memberof TagNested
     */
    'tagData'?: Array<TagDescNested>;
}
/**
 * 
 * @export
 * @interface TagRank
 */
export interface TagRank {
    /**
     * 태그 코드
     * @type {string}
     * @memberof TagRank
     */
    'tagCode': string;
    /**
     * 태그 코드 등장 횟수
     * @type {number}
     * @memberof TagRank
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface TagRankingResp
 */
export interface TagRankingResp {
    /**
     * 
     * @type {Array<TagRank>}
     * @memberof TagRankingResp
     */
    'tagRankInfo'?: Array<TagRank>;
    /**
     * 
     * @type {Array<ResolutionInfo>}
     * @memberof TagRankingResp
     */
    'resolutionInfo'?: Array<ResolutionInfo>;
}
/**
 * 
 * @export
 * @interface TagTrendInput
 */
export interface TagTrendInput {
    /**
     * 
     * @type {string}
     * @memberof TagTrendInput
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof TagTrendInput
     */
    'end_date'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TagTrendInput
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ThrustBearingInfo
 */
export interface ThrustBearingInfo {
    /**
     * thrust bearing id
     * @type {number}
     * @memberof ThrustBearingInfo
     */
    'bearingId': number;
    /**
     * thrust bearing id
     * @type {string}
     * @memberof ThrustBearingInfo
     */
    'bearingName': string;
    /**
     * thrust bearing position
     * @type {number}
     * @memberof ThrustBearingInfo
     */
    'position': number;
    /**
     * thrust bearing active top temperature
     * @type {number}
     * @memberof ThrustBearingInfo
     */
    'activeTopTemperature': number;
    /**
     * thrust bearing active bottom temperature
     * @type {number}
     * @memberof ThrustBearingInfo
     */
    'activeBottomTemperature': number;
    /**
     * thrust bearing inactive top temperature 
     * @type {number}
     * @memberof ThrustBearingInfo
     */
    'inactiveTopTemperature': number;
    /**
     * thrust bearing inactive bottom temperature 
     * @type {number}
     * @memberof ThrustBearingInfo
     */
    'inactiveBottomTemperature': number;
}
/**
 * 
 * @export
 * @interface TroubleShootingList
 */
export interface TroubleShootingList {
    /**
     * 해당 베어링 정보 측정 시간
     * @type {string}
     * @memberof TroubleShootingList
     */
    'acqTime': string;
    /**
     * 
     * @type {Array<JournalBearingInfo>}
     * @memberof TroubleShootingList
     */
    'journalBearings'?: Array<JournalBearingInfo>;
}
/**
 * 
 * @export
 * @interface TroubleShootingResp
 */
export interface TroubleShootingResp {
    /**
     * 현재 페이지
     * @type {number}
     * @memberof TroubleShootingResp
     */
    'page': number;
    /**
     * 페이지당 게시물 수
     * @type {number}
     * @memberof TroubleShootingResp
     */
    'limit': number;
    /**
     * 총 게시물 개수
     * @type {number}
     * @memberof TroubleShootingResp
     */
    'totalCount': number;
    /**
     * 
     * @type {Array<TroubleShootingList>}
     * @memberof TroubleShootingResp
     */
    'troubleShootings'?: Array<TroubleShootingList>;
}
/**
 * 
 * @export
 * @interface TurbineDashboardInfo
 */
export interface TurbineDashboardInfo {
    /**
     * 터빈의 소속 호 아이디
     * @type {number}
     * @memberof TurbineDashboardInfo
     */
    'unitId': number;
    /**
     * 호기 이름
     * @type {string}
     * @memberof TurbineDashboardInfo
     */
    'unitName': string;
    /**
     * 
     * @type {Array<TurbineState>}
     * @memberof TurbineDashboardInfo
     */
    'turbines'?: Array<TurbineState>;
}
/**
 * 
 * @export
 * @interface TurbineSelection
 */
export interface TurbineSelection {
    /**
     * 
     * @type {Array<TurbineDashboardInfo>}
     * @memberof TurbineSelection
     */
    'units'?: Array<TurbineDashboardInfo>;
}
/**
 * 
 * @export
 * @interface TurbineState
 */
export interface TurbineState {
    /**
     * 터빈 아이디
     * @type {number}
     * @memberof TurbineState
     */
    'id': number;
    /**
     * 호기
     * @type {string}
     * @memberof TurbineState
     */
    'systemName': string;
    /**
     * 터빈 이름
     * @type {string}
     * @memberof TurbineState
     */
    'turbineName': string;
    /**
     * 터빈 태그 이름
     * @type {string}
     * @memberof TurbineState
     */
    'turbineTagName': string;
    /**
     * 터빈 타입(gas/steam)
     * @type {string}
     * @memberof TurbineState
     */
    'turbineType': string;
    /**
     * 운영모드(운영중지:0/운영중:1)
     * @type {number}
     * @memberof TurbineState
     */
    'operationMode': number;
    /**
     * 터빈이 있는 SITE ID
     * @type {number}
     * @memberof TurbineState
     */
    'siteInfoId': number;
    /**
     * 회전 방향
     * @type {string}
     * @memberof TurbineState
     */
    'rotationDirection'?: string;
    /**
     * 
     * @type {Array<FailureState>}
     * @memberof TurbineState
     */
    'turbineFailures'?: Array<FailureState>;
}
/**
 * 
 * @export
 * @interface UpdateBody
 */
export interface UpdateBody {
    /**
     * 점검일지 제목
     * @type {string}
     * @memberof UpdateBody
     */
    'title': string;
    /**
     * 작성자
     * @type {string}
     * @memberof UpdateBody
     */
    'inspector': string;
    /**
     * 점검일자
     * @type {string}
     * @memberof UpdateBody
     */
    'inspectionTime': string;
    /**
     * 상세 진단 내용
     * @type {string}
     * @memberof UpdateBody
     */
    'inspectionDetail': string;
    /**
     * 조치 내용
     * @type {string}
     * @memberof UpdateBody
     */
    'actionDetail': string;
}
/**
 * 
 * @export
 * @interface UserAnomalyList
 */
export interface UserAnomalyList {
    /**
     * 베어링 아이디
     * @type {string}
     * @memberof UserAnomalyList
     */
    'bearingId': string;
    /**
     * 베어링 이름
     * @type {string}
     * @memberof UserAnomalyList
     */
    'bearingName': string;
    /**
     * 베어링 상태(Warning, Trip)
     * @type {string}
     * @memberof UserAnomalyList
     */
    'state': string;
    /**
     * 진단시간
     * @type {string}
     * @memberof UserAnomalyList
     */
    'failureTime': string;
    /**
     * 베어링 상태(Warning, Trip)
     * @type {string}
     * @memberof UserAnomalyList
     */
    'failureDetail': string;
}
/**
 * 
 * @export
 * @interface UserAuthority
 */
export interface UserAuthority {
    /**
     * 사용자 권한
     * @type {string}
     * @memberof UserAuthority
     */
    'authority': string;
}
/**
 * 
 * @export
 * @interface UserEventBody
 */
export interface UserEventBody {
    /**
     * 베어링 아이디
     * @type {number}
     * @memberof UserEventBody
     */
    'bearingId': number;
    /**
     * x,y축 통합 orbit data
     * @type {Array<Array<number>>}
     * @memberof UserEventBody
     */
    'orbitThreshold': Array<Array<number>>;
}
/**
 * 
 * @export
 * @interface UserEventList
 */
export interface UserEventList {
    /**
     * 이벤트 아이디
     * @type {number}
     * @memberof UserEventList
     */
    'id': number;
    /**
     * 이벤트 명
     * @type {string}
     * @memberof UserEventList
     */
    'eventName': string;
    /**
     * 이벤트 시작 시간
     * @type {string}
     * @memberof UserEventList
     */
    'startTime': string;
    /**
     * 이벤트 종료 시간
     * @type {string}
     * @memberof UserEventList
     */
    'endTime': string;
    /**
     * 이벤트 내용
     * @type {string}
     * @memberof UserEventList
     */
    'eventDetail': string;
}
/**
 * 
 * @export
 * @interface UserEventResult
 */
export interface UserEventResult {
    /**
     * 
     * @type {number}
     * @memberof UserEventResult
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserEventResult
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserEventResult
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<UserEventList>}
     * @memberof UserEventResult
     */
    'userEventList'?: Array<UserEventList>;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 사용자 아이디
     * @type {number}
     * @memberof UserInfo
     */
    'id': number;
    /**
     * 사용자 로그인 아이디
     * @type {string}
     * @memberof UserInfo
     */
    'userId': string;
    /**
     * 사용자명
     * @type {string}
     * @memberof UserInfo
     */
    'userName': string;
    /**
     * 회사명
     * @type {string}
     * @memberof UserInfo
     */
    'companyName': string;
    /**
     * 부서명
     * @type {string}
     * @memberof UserInfo
     */
    'teamName': string;
    /**
     * 핸드폰 번호
     * @type {string}
     * @memberof UserInfo
     */
    'phoneNum': string;
    /**
     * 이메일
     * @type {string}
     * @memberof UserInfo
     */
    'email': string;
    /**
     * 등록일자
     * @type {string}
     * @memberof UserInfo
     */
    'registerDate': string;
    /**
     * 계약만료일
     * @type {string}
     * @memberof UserInfo
     */
    'contractDueDate': string;
    /**
     * 사용자 권한
     * @type {string}
     * @memberof UserInfo
     */
    'authority': string;
}
/**
 * 
 * @export
 * @interface UserOrbitThreshold
 */
export interface UserOrbitThreshold {
    /**
     * 사용자 아이디
     * @type {number}
     * @memberof UserOrbitThreshold
     */
    'userId': number;
    /**
     * 베어링 아이디
     * @type {number}
     * @memberof UserOrbitThreshold
     */
    'bearingId': number;
    /**
     * 
     * @type {OrbitThreshold}
     * @memberof UserOrbitThreshold
     */
    'orbitThreshold'?: OrbitThreshold;
}
/**
 * 
 * @export
 * @interface VibCurrentPred
 */
export interface VibCurrentPred {
    /**
     * 10분 예측 값
     * @type {number}
     * @memberof VibCurrentPred
     */
    'plusMeanPred10': number;
    /**
     * 10분 예측 값
     * @type {number}
     * @memberof VibCurrentPred
     */
    'meanPred10': number;
    /**
     * 10분 예측 값
     * @type {number}
     * @memberof VibCurrentPred
     */
    'minusMeanPred10': number;
    /**
     * 10분 예측 값
     * @type {number}
     * @memberof VibCurrentPred
     */
    'plusMeanPred20': number;
    /**
     * 10분 예측 값
     * @type {number}
     * @memberof VibCurrentPred
     */
    'meanPred20': number;
    /**
     * 10분 예측 값
     * @type {number}
     * @memberof VibCurrentPred
     */
    'minusMeanPred20': number;
    /**
     * 10분 예측 값
     * @type {number}
     * @memberof VibCurrentPred
     */
    'plusMeanPred30': number;
    /**
     * 10분 예측 값
     * @type {number}
     * @memberof VibCurrentPred
     */
    'meanPred30': number;
    /**
     * 10분 예측 값
     * @type {number}
     * @memberof VibCurrentPred
     */
    'minusMeanPred30': number;
}
/**
 * 
 * @export
 * @interface VibPredDashboard
 */
export interface VibPredDashboard {
    /**
     * 
     * @type {GasGenerationInfo}
     * @memberof VibPredDashboard
     */
    'gasGeneration'?: GasGenerationInfo;
    /**
     * 
     * @type {SteamGenerationInfo}
     * @memberof VibPredDashboard
     */
    'steamGeneration'?: SteamGenerationInfo;
    /**
     * 
     * @type {Array<JournalBearingInfo>}
     * @memberof VibPredDashboard
     */
    'journalBearing'?: Array<JournalBearingInfo>;
    /**
     * 
     * @type {Array<ThrustBearingInfo>}
     * @memberof VibPredDashboard
     */
    'thrustBearing'?: Array<ThrustBearingInfo>;
    /**
     * 
     * @type {Array<JournalBearingInfo>}
     * @memberof VibPredDashboard
     */
    'predJournalBearing'?: Array<JournalBearingInfo>;
    /**
     * 
     * @type {Array<VibrationPrediction>}
     * @memberof VibPredDashboard
     */
    'vibrationPrediction'?: Array<VibrationPrediction>;
}
/**
 * 
 * @export
 * @interface VibPredModel
 */
export interface VibPredModel {
    /**
     * 모델 아이디
     * @type {number}
     * @memberof VibPredModel
     */
    'modelId': number;
    /**
     * 모델 이름
     * @type {string}
     * @memberof VibPredModel
     */
    'name': string;
    /**
     * 모델 설명
     * @type {string}
     * @memberof VibPredModel
     */
    'description': string;
    /**
     * R스퀘어 값
     * @type {number}
     * @memberof VibPredModel
     */
    'xRSquare': number;
    /**
     * R스퀘어 값
     * @type {number}
     * @memberof VibPredModel
     */
    'yRSquare': number;
    /**
     * 예측 정확도
     * @type {number}
     * @memberof VibPredModel
     */
    'xPredictAccuracy': number;
    /**
     * 예측 정확도
     * @type {number}
     * @memberof VibPredModel
     */
    'yPredictAccuracy': number;
    /**
     * 타임스탬프 값
     * @type {Array<string>}
     * @memberof VibPredModel
     */
    'timestamp': Array<string>;
    /**
     * 해당 베어링 X 실측값
     * @type {Array<number>}
     * @memberof VibPredModel
     */
    'xReal': Array<number>;
    /**
     * 해당 베어링 X 예측값
     * @type {Array<number>}
     * @memberof VibPredModel
     */
    'xPredict': Array<number>;
    /**
     * 해당 베어링 Y 실측값
     * @type {Array<number>}
     * @memberof VibPredModel
     */
    'yReal': Array<number>;
    /**
     * 해당 베어링 Y 예측값
     * @type {Array<number>}
     * @memberof VibPredModel
     */
    'yPredict': Array<number>;
    /**
     * 해당 베어링 X 최신 예측값
     * @type {VibCurrentPred}
     * @memberof VibPredModel
     */
    'xCurrentPredict': VibCurrentPred;
    /**
     * 해당 베어링 Y 최신 예측값
     * @type {VibCurrentPred}
     * @memberof VibPredModel
     */
    'yCurrentPredict': VibCurrentPred;
}
/**
 * 
 * @export
 * @interface VibPredModelResp
 */
export interface VibPredModelResp {
    /**
     * 해당 베어링의 예측 데이터들
     * @type {Array<VibPredModel>}
     * @memberof VibPredModelResp
     */
    'models': Array<VibPredModel>;
}
/**
 * 
 * @export
 * @interface VibrationDigitalTwinInfo
 */
export interface VibrationDigitalTwinInfo {
    /**
     * 계측시간
     * @type {string}
     * @memberof VibrationDigitalTwinInfo
     */
    'acqTime': string;
    /**
     * 
     * @type {Array<JournalBearingInfo>}
     * @memberof VibrationDigitalTwinInfo
     */
    'journalBearing'?: Array<JournalBearingInfo>;
    /**
     * 
     * @type {Array<ThrustBearingInfo>}
     * @memberof VibrationDigitalTwinInfo
     */
    'thrustBearing'?: Array<ThrustBearingInfo>;
    /**
     * 
     * @type {Array<BearingOrbitData>}
     * @memberof VibrationDigitalTwinInfo
     */
    'bearings'?: Array<BearingOrbitData>;
}
/**
 * 
 * @export
 * @interface VibrationPrediction
 */
export interface VibrationPrediction {
    /**
     * thrust bearing id
     * @type {number}
     * @memberof VibrationPrediction
     */
    'bearingId': number;
    /**
     * thrust bearing id
     * @type {string}
     * @memberof VibrationPrediction
     */
    'bearingName': string;
    /**
     * 베어링 X 축 예측값 10분
     * @type {number}
     * @memberof VibrationPrediction
     */
    'xRiskPred10': number;
    /**
     * 베어링 Y 축 예측값 10분
     * @type {number}
     * @memberof VibrationPrediction
     */
    'yRiskPred10': number;
    /**
     * 베어링 X 축 예측값 10분
     * @type {number}
     * @memberof VibrationPrediction
     */
    'xRiskPred20': number;
    /**
     * 베어링 Y 축 예측값 10분
     * @type {number}
     * @memberof VibrationPrediction
     */
    'yRiskPred20': number;
    /**
     * 베어링 X 축 예측값 10분
     * @type {number}
     * @memberof VibrationPrediction
     */
    'xRiskPred30': number;
    /**
     * 베어링 Y 축 예측값 10분
     * @type {number}
     * @memberof VibrationPrediction
     */
    'yRiskPred30': number;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 비밀번호 변경
         * @param {ChangePassword} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChangePassword: async (payload: ChangePassword, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postChangePassword', 'payload', payload)
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 사용자 로그인
         * @param {InputLogin} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogin: async (payload: InputLogin, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postLogin', 'payload', payload)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 사용자 로그아웃
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogout: async (authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('postLogout', 'authorization', authorization)
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 비밀번호 변경
         * @param {ChangePassword} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChangePassword(payload: ChangePassword, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postChangePassword(payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 사용자 로그인
         * @param {InputLogin} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLogin(payload: InputLogin, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutputLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLogin(payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 사용자 로그아웃
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLogout(authorization: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLogout(authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary 비밀번호 변경
         * @param {ChangePassword} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChangePassword(payload: ChangePassword, options?: any): AxiosPromise<void> {
            return localVarFp.postChangePassword(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 사용자 로그인
         * @param {InputLogin} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogin(payload: InputLogin, options?: any): AxiosPromise<OutputLogin> {
            return localVarFp.postLogin(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 사용자 로그아웃
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogout(authorization: string, options?: any): AxiosPromise<void> {
            return localVarFp.postLogout(authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary 비밀번호 변경
     * @param {ChangePassword} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postChangePassword(payload: ChangePassword, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).postChangePassword(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 사용자 로그인
     * @param {InputLogin} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postLogin(payload: InputLogin, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).postLogin(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 사용자 로그아웃
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postLogout(authorization: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).postLogout(authorization, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary bearing 정보
         * @param {number} turbineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardBearingInfo: async (turbineId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getDashboardBearingInfo', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/bearings/status`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 진단 이상 감지 내역
         * @param {number} turbineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardFailureInfo: async (turbineId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getDashboardFailureInfo', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/bearings/diagnosis`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary bearing 정보
         * @param {number} turbineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardBearingInfo(turbineId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardBearing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardBearingInfo(turbineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 진단 이상 감지 내역
         * @param {number} turbineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardFailureInfo(turbineId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardDiagnosis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardFailureInfo(turbineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardApiFp(configuration)
    return {
        /**
         * 
         * @summary bearing 정보
         * @param {number} turbineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardBearingInfo(turbineId: number, options?: any): AxiosPromise<DashboardBearing> {
            return localVarFp.getDashboardBearingInfo(turbineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 진단 이상 감지 내역
         * @param {number} turbineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardFailureInfo(turbineId: number, options?: any): AxiosPromise<DashboardDiagnosis> {
            return localVarFp.getDashboardFailureInfo(turbineId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * 
     * @summary bearing 정보
     * @param {number} turbineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboardBearingInfo(turbineId: number, options?: AxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDashboardBearingInfo(turbineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 진단 이상 감지 내역
     * @param {number} turbineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboardFailureInfo(turbineId: number, options?: AxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDashboardFailureInfo(turbineId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataSearchApi - axios parameter creator
 * @export
 */
export const DataSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 디테일: bode/polar 그래프
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphBodePolarDetail: async (turbineId: number, acqTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getDataGraphBodePolarDetail', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/bearings/graphs/bode-polar`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acqTime !== undefined) {
                localVarQueryParameter['acq_time'] = acqTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 디테일: fft 그래프
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphFftDetail: async (turbineId: number, acqTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getDataGraphFftDetail', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/bearings/graphs/fft`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acqTime !== undefined) {
                localVarQueryParameter['acq_time'] = acqTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 디테일: orbit 그래프
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphOrbitDetail: async (turbineId: number, acqTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getDataGraphOrbitDetail', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/bearings/graphs/orbit`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acqTime !== undefined) {
                localVarQueryParameter['acq_time'] = acqTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 오버뷰: 폴라 그래프 정보 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphOverviewBodePolar: async (turbineId: number, acqTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getDataGraphOverviewBodePolar', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/bearings/graphs/overview/bode-polar`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acqTime !== undefined) {
                localVarQueryParameter['acq_time'] = acqTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 오버뷰: FFT 그래프 정보 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphOverviewFft: async (turbineId: number, acqTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getDataGraphOverviewFft', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/bearings/graphs/overview/fft`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acqTime !== undefined) {
                localVarQueryParameter['acq_time'] = acqTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 오버뷰: ORBIT 그래프 정보 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphOverviewOrbit: async (turbineId: number, acqTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getDataGraphOverviewOrbit', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/bearings/graphs/overview/orbit`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acqTime !== undefined) {
                localVarQueryParameter['acq_time'] = acqTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 오버뷰: 데이터 조회를 위한 기간 조회
         * @param {number} turbineId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphOverviewSearch: async (turbineId: number, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getDataGraphOverviewSearch', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/bearings/graphs/overview`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 오버뷰: Shaft center line 그래프 정보 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphOverviewShaftCenterLine: async (turbineId: number, acqTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getDataGraphOverviewShaftCenterLine', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/bearings/graphs/overview/shaft`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acqTime !== undefined) {
                localVarQueryParameter['acq_time'] = acqTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 디테일: shaft centerline 그래프
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphShaftDetail: async (turbineId: number, acqTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getDataGraphShaftDetail', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/bearings/graphs/shaft`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acqTime !== undefined) {
                localVarQueryParameter['acq_time'] = acqTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 디테일: shaft centerline 그래프
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphShaftDetail_1: async (turbineId: number, acqTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getDataGraphShaftDetail_1', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/bearings/graphs/shafts`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acqTime !== undefined) {
                localVarQueryParameter['acq_time'] = acqTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 디테일: vibration 그래프
         * @param {number} turbineId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphVibrationDetail: async (turbineId: number, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getDataGraphVibrationDetail', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/bearings/graphs/vibration`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataSearchApi - functional programming interface
 * @export
 */
export const DataSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 디테일: bode/polar 그래프
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataGraphBodePolarDetail(turbineId: number, acqTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGraphBodePolar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataGraphBodePolarDetail(turbineId, acqTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 디테일: fft 그래프
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataGraphFftDetail(turbineId: number, acqTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGraphFft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataGraphFftDetail(turbineId, acqTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 디테일: orbit 그래프
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataGraphOrbitDetail(turbineId: number, acqTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGraphOverviewOrbit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataGraphOrbitDetail(turbineId, acqTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 오버뷰: 폴라 그래프 정보 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataGraphOverviewBodePolar(turbineId: number, acqTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGraphBodePolar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataGraphOverviewBodePolar(turbineId, acqTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 오버뷰: FFT 그래프 정보 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataGraphOverviewFft(turbineId: number, acqTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGraphFft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataGraphOverviewFft(turbineId, acqTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 오버뷰: ORBIT 그래프 정보 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataGraphOverviewOrbit(turbineId: number, acqTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGraphOverviewOrbit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataGraphOverviewOrbit(turbineId, acqTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 오버뷰: 데이터 조회를 위한 기간 조회
         * @param {number} turbineId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataGraphOverviewSearch(turbineId: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchDataSlider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataGraphOverviewSearch(turbineId, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 오버뷰: Shaft center line 그래프 정보 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataGraphOverviewShaftCenterLine(turbineId: number, acqTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGraphShaftCenter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataGraphOverviewShaftCenterLine(turbineId, acqTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 디테일: shaft centerline 그래프
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataGraphShaftDetail(turbineId: number, acqTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGraphShaftCenter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataGraphShaftDetail(turbineId, acqTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 디테일: shaft centerline 그래프
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataGraphShaftDetail_1(turbineId: number, acqTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGraphShaftCenter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataGraphShaftDetail_1(turbineId, acqTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 디테일: vibration 그래프
         * @param {number} turbineId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataGraphVibrationDetail(turbineId: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGraphOverviewVibration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataGraphVibrationDetail(turbineId, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataSearchApi - factory interface
 * @export
 */
export const DataSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataSearchApiFp(configuration)
    return {
        /**
         * 
         * @summary 디테일: bode/polar 그래프
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphBodePolarDetail(turbineId: number, acqTime?: string, options?: any): AxiosPromise<DataGraphBodePolar> {
            return localVarFp.getDataGraphBodePolarDetail(turbineId, acqTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 디테일: fft 그래프
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphFftDetail(turbineId: number, acqTime?: string, options?: any): AxiosPromise<DataGraphFft> {
            return localVarFp.getDataGraphFftDetail(turbineId, acqTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 디테일: orbit 그래프
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphOrbitDetail(turbineId: number, acqTime?: string, options?: any): AxiosPromise<DataGraphOverviewOrbit> {
            return localVarFp.getDataGraphOrbitDetail(turbineId, acqTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 오버뷰: 폴라 그래프 정보 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphOverviewBodePolar(turbineId: number, acqTime?: string, options?: any): AxiosPromise<DataGraphBodePolar> {
            return localVarFp.getDataGraphOverviewBodePolar(turbineId, acqTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 오버뷰: FFT 그래프 정보 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphOverviewFft(turbineId: number, acqTime?: string, options?: any): AxiosPromise<DataGraphFft> {
            return localVarFp.getDataGraphOverviewFft(turbineId, acqTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 오버뷰: ORBIT 그래프 정보 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphOverviewOrbit(turbineId: number, acqTime?: string, options?: any): AxiosPromise<DataGraphOverviewOrbit> {
            return localVarFp.getDataGraphOverviewOrbit(turbineId, acqTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 오버뷰: 데이터 조회를 위한 기간 조회
         * @param {number} turbineId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphOverviewSearch(turbineId: number, startDate?: string, endDate?: string, options?: any): AxiosPromise<SearchDataSlider> {
            return localVarFp.getDataGraphOverviewSearch(turbineId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 오버뷰: Shaft center line 그래프 정보 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphOverviewShaftCenterLine(turbineId: number, acqTime?: string, options?: any): AxiosPromise<DataGraphShaftCenter> {
            return localVarFp.getDataGraphOverviewShaftCenterLine(turbineId, acqTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 디테일: shaft centerline 그래프
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphShaftDetail(turbineId: number, acqTime?: string, options?: any): AxiosPromise<DataGraphShaftCenter> {
            return localVarFp.getDataGraphShaftDetail(turbineId, acqTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 디테일: shaft centerline 그래프
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphShaftDetail_1(turbineId: number, acqTime?: string, options?: any): AxiosPromise<DataGraphShaftCenter> {
            return localVarFp.getDataGraphShaftDetail_1(turbineId, acqTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 디테일: vibration 그래프
         * @param {number} turbineId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataGraphVibrationDetail(turbineId: number, startDate?: string, endDate?: string, options?: any): AxiosPromise<DataGraphOverviewVibration> {
            return localVarFp.getDataGraphVibrationDetail(turbineId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSearchApi - object-oriented interface
 * @export
 * @class DataSearchApi
 * @extends {BaseAPI}
 */
export class DataSearchApi extends BaseAPI {
    /**
     * 
     * @summary 디테일: bode/polar 그래프
     * @param {number} turbineId 
     * @param {string} [acqTime] 특정 조회 시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSearchApi
     */
    public getDataGraphBodePolarDetail(turbineId: number, acqTime?: string, options?: AxiosRequestConfig) {
        return DataSearchApiFp(this.configuration).getDataGraphBodePolarDetail(turbineId, acqTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 디테일: fft 그래프
     * @param {number} turbineId 
     * @param {string} [acqTime] 특정 조회 시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSearchApi
     */
    public getDataGraphFftDetail(turbineId: number, acqTime?: string, options?: AxiosRequestConfig) {
        return DataSearchApiFp(this.configuration).getDataGraphFftDetail(turbineId, acqTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 디테일: orbit 그래프
     * @param {number} turbineId 
     * @param {string} [acqTime] 특정 조회 시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSearchApi
     */
    public getDataGraphOrbitDetail(turbineId: number, acqTime?: string, options?: AxiosRequestConfig) {
        return DataSearchApiFp(this.configuration).getDataGraphOrbitDetail(turbineId, acqTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 오버뷰: 폴라 그래프 정보 조회
     * @param {number} turbineId 
     * @param {string} [acqTime] 특정 조회 시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSearchApi
     */
    public getDataGraphOverviewBodePolar(turbineId: number, acqTime?: string, options?: AxiosRequestConfig) {
        return DataSearchApiFp(this.configuration).getDataGraphOverviewBodePolar(turbineId, acqTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 오버뷰: FFT 그래프 정보 조회
     * @param {number} turbineId 
     * @param {string} [acqTime] 특정 조회 시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSearchApi
     */
    public getDataGraphOverviewFft(turbineId: number, acqTime?: string, options?: AxiosRequestConfig) {
        return DataSearchApiFp(this.configuration).getDataGraphOverviewFft(turbineId, acqTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 오버뷰: ORBIT 그래프 정보 조회
     * @param {number} turbineId 
     * @param {string} [acqTime] 특정 조회 시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSearchApi
     */
    public getDataGraphOverviewOrbit(turbineId: number, acqTime?: string, options?: AxiosRequestConfig) {
        return DataSearchApiFp(this.configuration).getDataGraphOverviewOrbit(turbineId, acqTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 오버뷰: 데이터 조회를 위한 기간 조회
     * @param {number} turbineId 
     * @param {string} [startDate] 조회 시작시간
     * @param {string} [endDate] 조회 종료시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSearchApi
     */
    public getDataGraphOverviewSearch(turbineId: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return DataSearchApiFp(this.configuration).getDataGraphOverviewSearch(turbineId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 오버뷰: Shaft center line 그래프 정보 조회
     * @param {number} turbineId 
     * @param {string} [acqTime] 특정 조회 시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSearchApi
     */
    public getDataGraphOverviewShaftCenterLine(turbineId: number, acqTime?: string, options?: AxiosRequestConfig) {
        return DataSearchApiFp(this.configuration).getDataGraphOverviewShaftCenterLine(turbineId, acqTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 디테일: shaft centerline 그래프
     * @param {number} turbineId 
     * @param {string} [acqTime] 특정 조회 시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSearchApi
     */
    public getDataGraphShaftDetail(turbineId: number, acqTime?: string, options?: AxiosRequestConfig) {
        return DataSearchApiFp(this.configuration).getDataGraphShaftDetail(turbineId, acqTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 디테일: shaft centerline 그래프
     * @param {number} turbineId 
     * @param {string} [acqTime] 특정 조회 시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSearchApi
     */
    public getDataGraphShaftDetail_1(turbineId: number, acqTime?: string, options?: AxiosRequestConfig) {
        return DataSearchApiFp(this.configuration).getDataGraphShaftDetail_1(turbineId, acqTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 디테일: vibration 그래프
     * @param {number} turbineId 
     * @param {string} [startDate] 조회 시작시간
     * @param {string} [endDate] 조회 종료시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSearchApi
     */
    public getDataGraphVibrationDetail(turbineId: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return DataSearchApiFp(this.configuration).getDataGraphVibrationDetail(turbineId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health check 결과 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health-check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health check 결과 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealthCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealthCheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Health check 결과 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthCheck(options?: any): AxiosPromise<object> {
            return localVarFp.getHealthCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Health check 결과 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public getHealthCheck(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getHealthCheck(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InspectionLogApi - axios parameter creator
 * @export
 */
export const InspectionLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 점검 일지 조회
         * @param {number} turbineId 
         * @param {number} inspectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInspectionLogLookup: async (turbineId: number, inspectionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getInspectionLogLookup', 'turbineId', turbineId)
            // verify required parameter 'inspectionId' is not null or undefined
            assertParamExists('getInspectionLogLookup', 'inspectionId', inspectionId)
            const localVarPath = `/turbines/{turbine_id}/inspection-logs/{inspection_id}`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)))
                .replace(`{${"inspection_id"}}`, encodeURIComponent(String(inspectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 점검 일지 등록
         * @param {number} turbineId 
         * @param {CreateBody} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInspectionLog: async (turbineId: number, payload: CreateBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('postInspectionLog', 'turbineId', turbineId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postInspectionLog', 'payload', payload)
            const localVarPath = `/turbines/{turbine_id}/inspection-logs`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 점검 일지 수정
         * @param {number} turbineId 
         * @param {number} inspectionId 
         * @param {UpdateBody} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInspectionLogLookup: async (turbineId: number, inspectionId: number, payload: UpdateBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('putInspectionLogLookup', 'turbineId', turbineId)
            // verify required parameter 'inspectionId' is not null or undefined
            assertParamExists('putInspectionLogLookup', 'inspectionId', inspectionId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('putInspectionLogLookup', 'payload', payload)
            const localVarPath = `/turbines/{turbine_id}/inspection-logs/{inspection_id}`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)))
                .replace(`{${"inspection_id"}}`, encodeURIComponent(String(inspectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InspectionLogApi - functional programming interface
 * @export
 */
export const InspectionLogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InspectionLogApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 점검 일지 조회
         * @param {number} turbineId 
         * @param {number} inspectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInspectionLogLookup(turbineId: number, inspectionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InspectionInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInspectionLogLookup(turbineId, inspectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 점검 일지 등록
         * @param {number} turbineId 
         * @param {CreateBody} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postInspectionLog(turbineId: number, payload: CreateBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InspectionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postInspectionLog(turbineId, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 점검 일지 수정
         * @param {number} turbineId 
         * @param {number} inspectionId 
         * @param {UpdateBody} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putInspectionLogLookup(turbineId: number, inspectionId: number, payload: UpdateBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InspectionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putInspectionLogLookup(turbineId, inspectionId, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InspectionLogApi - factory interface
 * @export
 */
export const InspectionLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InspectionLogApiFp(configuration)
    return {
        /**
         * 
         * @summary 점검 일지 조회
         * @param {number} turbineId 
         * @param {number} inspectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInspectionLogLookup(turbineId: number, inspectionId: number, options?: any): AxiosPromise<Array<InspectionInfo>> {
            return localVarFp.getInspectionLogLookup(turbineId, inspectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 점검 일지 등록
         * @param {number} turbineId 
         * @param {CreateBody} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postInspectionLog(turbineId: number, payload: CreateBody, options?: any): AxiosPromise<InspectionInfo> {
            return localVarFp.postInspectionLog(turbineId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 점검 일지 수정
         * @param {number} turbineId 
         * @param {number} inspectionId 
         * @param {UpdateBody} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInspectionLogLookup(turbineId: number, inspectionId: number, payload: UpdateBody, options?: any): AxiosPromise<InspectionInfo> {
            return localVarFp.putInspectionLogLookup(turbineId, inspectionId, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InspectionLogApi - object-oriented interface
 * @export
 * @class InspectionLogApi
 * @extends {BaseAPI}
 */
export class InspectionLogApi extends BaseAPI {
    /**
     * 
     * @summary 점검 일지 조회
     * @param {number} turbineId 
     * @param {number} inspectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectionLogApi
     */
    public getInspectionLogLookup(turbineId: number, inspectionId: number, options?: AxiosRequestConfig) {
        return InspectionLogApiFp(this.configuration).getInspectionLogLookup(turbineId, inspectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 점검 일지 등록
     * @param {number} turbineId 
     * @param {CreateBody} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectionLogApi
     */
    public postInspectionLog(turbineId: number, payload: CreateBody, options?: AxiosRequestConfig) {
        return InspectionLogApiFp(this.configuration).postInspectionLog(turbineId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 점검 일지 수정
     * @param {number} turbineId 
     * @param {number} inspectionId 
     * @param {UpdateBody} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectionLogApi
     */
    public putInspectionLogLookup(turbineId: number, inspectionId: number, payload: UpdateBody, options?: AxiosRequestConfig) {
        return InspectionLogApiFp(this.configuration).putInspectionLogLookup(turbineId, inspectionId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemEventApi - axios parameter creator
 * @export
 */
export const SystemEventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 시스템 이벤트 목록 조회
         * @param {number} turbineId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {string} [page] 페이지, 없으면 디폴트 1
         * @param {string} [limit] 페이지당 개수, 없으면 디폴트 20
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemEvent: async (turbineId: number, startDate?: string, endDate?: string, page?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getSystemEvent', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/system-events`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemEventApi - functional programming interface
 * @export
 */
export const SystemEventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemEventApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 시스템 이벤트 목록 조회
         * @param {number} turbineId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {string} [page] 페이지, 없으면 디폴트 1
         * @param {string} [limit] 페이지당 개수, 없으면 디폴트 20
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemEvent(turbineId: number, startDate?: string, endDate?: string, page?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemEventResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemEvent(turbineId, startDate, endDate, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemEventApi - factory interface
 * @export
 */
export const SystemEventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemEventApiFp(configuration)
    return {
        /**
         * 
         * @summary 시스템 이벤트 목록 조회
         * @param {number} turbineId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {string} [page] 페이지, 없으면 디폴트 1
         * @param {string} [limit] 페이지당 개수, 없으면 디폴트 20
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemEvent(turbineId: number, startDate?: string, endDate?: string, page?: string, limit?: string, options?: any): AxiosPromise<SystemEventResult> {
            return localVarFp.getSystemEvent(turbineId, startDate, endDate, page, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemEventApi - object-oriented interface
 * @export
 * @class SystemEventApi
 * @extends {BaseAPI}
 */
export class SystemEventApi extends BaseAPI {
    /**
     * 
     * @summary 시스템 이벤트 목록 조회
     * @param {number} turbineId 
     * @param {string} [startDate] 조회 시작시간
     * @param {string} [endDate] 조회 종료시간
     * @param {string} [page] 페이지, 없으면 디폴트 1
     * @param {string} [limit] 페이지당 개수, 없으면 디폴트 20
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemEventApi
     */
    public getSystemEvent(turbineId: number, startDate?: string, endDate?: string, page?: string, limit?: string, options?: AxiosRequestConfig) {
        return SystemEventApiFp(this.configuration).getSystemEvent(turbineId, startDate, endDate, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagTrendApi - axios parameter creator
 * @export
 */
export const TagTrendApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 태그 목록 및 추천 태그 리스트 조회
         * @param {number} turbineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagList: async (turbineId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getTagList', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/process-data/tags`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 태그 트렌드 그래프 조회
         * @param {number} turbineId 
         * @param {TagTrendInput} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTagList: async (turbineId: number, payload: TagTrendInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('postTagList', 'turbineId', turbineId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postTagList', 'payload', payload)
            const localVarPath = `/turbines/{turbine_id}/process-data/tags`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagTrendApi - functional programming interface
 * @export
 */
export const TagTrendApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagTrendApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 태그 목록 및 추천 태그 리스트 조회
         * @param {number} turbineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagList(turbineId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagList(turbineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 태그 트렌드 그래프 조회
         * @param {number} turbineId 
         * @param {TagTrendInput} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTagList(turbineId: number, payload: TagTrendInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagDataList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTagList(turbineId, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagTrendApi - factory interface
 * @export
 */
export const TagTrendApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagTrendApiFp(configuration)
    return {
        /**
         * 
         * @summary 태그 목록 및 추천 태그 리스트 조회
         * @param {number} turbineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagList(turbineId: number, options?: any): AxiosPromise<TagList> {
            return localVarFp.getTagList(turbineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 태그 트렌드 그래프 조회
         * @param {number} turbineId 
         * @param {TagTrendInput} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTagList(turbineId: number, payload: TagTrendInput, options?: any): AxiosPromise<TagDataList> {
            return localVarFp.postTagList(turbineId, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagTrendApi - object-oriented interface
 * @export
 * @class TagTrendApi
 * @extends {BaseAPI}
 */
export class TagTrendApi extends BaseAPI {
    /**
     * 
     * @summary 태그 목록 및 추천 태그 리스트 조회
     * @param {number} turbineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagTrendApi
     */
    public getTagList(turbineId: number, options?: AxiosRequestConfig) {
        return TagTrendApiFp(this.configuration).getTagList(turbineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 태그 트렌드 그래프 조회
     * @param {number} turbineId 
     * @param {TagTrendInput} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagTrendApi
     */
    public postTagList(turbineId: number, payload: TagTrendInput, options?: AxiosRequestConfig) {
        return TagTrendApiFp(this.configuration).postTagList(turbineId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TroubleShootingApi - axios parameter creator
 * @export
 */
export const TroubleShootingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 베어링 보고서
         * @param {number} turbineId 
         * @param {number} bearingId 
         * @param {string} acqTime 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingReport: async (turbineId: number, bearingId: number, acqTime: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getBearingReport', 'turbineId', turbineId)
            // verify required parameter 'bearingId' is not null or undefined
            assertParamExists('getBearingReport', 'bearingId', bearingId)
            // verify required parameter 'acqTime' is not null or undefined
            assertParamExists('getBearingReport', 'acqTime', acqTime)
            const localVarPath = `/turbines/{turbine_id}/trouble-shooting/reports/{bearing_id}`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)))
                .replace(`{${"bearing_id"}}`, encodeURIComponent(String(bearingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acqTime !== undefined) {
                localVarQueryParameter['acq_time'] = acqTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 베어링 시스템 이벤트 보고서
         * @param {number} turbineId 
         * @param {string} [page] 페이지, 없으면 디폴트 1
         * @param {string} [limit] 페이지당 개수, 없으면 디폴트 20
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemEvent: async (turbineId: number, page?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getSystemEvent', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/trouble-shooting/events`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 운전인자 태그 랭킹
         * @param {number} turbineId 
         * @param {string} startDate 조회 시작시간
         * @param {string} endDate 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagRank: async (turbineId: number, startDate: string, endDate: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getTagRank', 'turbineId', turbineId)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('getTagRank', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('getTagRank', 'endDate', endDate)
            const localVarPath = `/turbines/{turbine_id}/trouble-shooting/tag-rank`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 트러블 슈팅 현황내역
         * @param {number} turbineId 
         * @param {string} startDate 조회 시작시간
         * @param {string} endDate 조회 종료시간
         * @param {string} [page] 페이지, 없으면 디폴트 1
         * @param {string} [limit] 페이지당 개수, 없으면 디폴트 20
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTroubleShootingHistory: async (turbineId: number, startDate: string, endDate: string, page?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getTroubleShootingHistory', 'turbineId', turbineId)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('getTroubleShootingHistory', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('getTroubleShootingHistory', 'endDate', endDate)
            const localVarPath = `/turbines/{turbine_id}/trouble-shooting`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TroubleShootingApi - functional programming interface
 * @export
 */
export const TroubleShootingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TroubleShootingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 베어링 보고서
         * @param {number} turbineId 
         * @param {number} bearingId 
         * @param {string} acqTime 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBearingReport(turbineId: number, bearingId: number, acqTime: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportRest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBearingReport(turbineId, bearingId, acqTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 베어링 시스템 이벤트 보고서
         * @param {number} turbineId 
         * @param {string} [page] 페이지, 없으면 디폴트 1
         * @param {string} [limit] 페이지당 개수, 없으면 디폴트 20
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemEvent(turbineId: number, page?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemEventResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemEvent(turbineId, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 운전인자 태그 랭킹
         * @param {number} turbineId 
         * @param {string} startDate 조회 시작시간
         * @param {string} endDate 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagRank(turbineId: number, startDate: string, endDate: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagRankingResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagRank(turbineId, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 트러블 슈팅 현황내역
         * @param {number} turbineId 
         * @param {string} startDate 조회 시작시간
         * @param {string} endDate 조회 종료시간
         * @param {string} [page] 페이지, 없으면 디폴트 1
         * @param {string} [limit] 페이지당 개수, 없으면 디폴트 20
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTroubleShootingHistory(turbineId: number, startDate: string, endDate: string, page?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TroubleShootingResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTroubleShootingHistory(turbineId, startDate, endDate, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TroubleShootingApi - factory interface
 * @export
 */
export const TroubleShootingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TroubleShootingApiFp(configuration)
    return {
        /**
         * 
         * @summary 베어링 보고서
         * @param {number} turbineId 
         * @param {number} bearingId 
         * @param {string} acqTime 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingReport(turbineId: number, bearingId: number, acqTime: string, options?: any): AxiosPromise<ReportRest> {
            return localVarFp.getBearingReport(turbineId, bearingId, acqTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 베어링 시스템 이벤트 보고서
         * @param {number} turbineId 
         * @param {string} [page] 페이지, 없으면 디폴트 1
         * @param {string} [limit] 페이지당 개수, 없으면 디폴트 20
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemEvent(turbineId: number, page?: string, limit?: string, options?: any): AxiosPromise<SystemEventResp> {
            return localVarFp.getSystemEvent(turbineId, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 운전인자 태그 랭킹
         * @param {number} turbineId 
         * @param {string} startDate 조회 시작시간
         * @param {string} endDate 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagRank(turbineId: number, startDate: string, endDate: string, options?: any): AxiosPromise<TagRankingResp> {
            return localVarFp.getTagRank(turbineId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 트러블 슈팅 현황내역
         * @param {number} turbineId 
         * @param {string} startDate 조회 시작시간
         * @param {string} endDate 조회 종료시간
         * @param {string} [page] 페이지, 없으면 디폴트 1
         * @param {string} [limit] 페이지당 개수, 없으면 디폴트 20
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTroubleShootingHistory(turbineId: number, startDate: string, endDate: string, page?: string, limit?: string, options?: any): AxiosPromise<TroubleShootingResp> {
            return localVarFp.getTroubleShootingHistory(turbineId, startDate, endDate, page, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TroubleShootingApi - object-oriented interface
 * @export
 * @class TroubleShootingApi
 * @extends {BaseAPI}
 */
export class TroubleShootingApi extends BaseAPI {
    /**
     * 
     * @summary 베어링 보고서
     * @param {number} turbineId 
     * @param {number} bearingId 
     * @param {string} acqTime 조회 시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TroubleShootingApi
     */
    public getBearingReport(turbineId: number, bearingId: number, acqTime: string, options?: AxiosRequestConfig) {
        return TroubleShootingApiFp(this.configuration).getBearingReport(turbineId, bearingId, acqTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 베어링 시스템 이벤트 보고서
     * @param {number} turbineId 
     * @param {string} [page] 페이지, 없으면 디폴트 1
     * @param {string} [limit] 페이지당 개수, 없으면 디폴트 20
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TroubleShootingApi
     */
    public getSystemEvent(turbineId: number, page?: string, limit?: string, options?: AxiosRequestConfig) {
        return TroubleShootingApiFp(this.configuration).getSystemEvent(turbineId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 운전인자 태그 랭킹
     * @param {number} turbineId 
     * @param {string} startDate 조회 시작시간
     * @param {string} endDate 조회 종료시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TroubleShootingApi
     */
    public getTagRank(turbineId: number, startDate: string, endDate: string, options?: AxiosRequestConfig) {
        return TroubleShootingApiFp(this.configuration).getTagRank(turbineId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 트러블 슈팅 현황내역
     * @param {number} turbineId 
     * @param {string} startDate 조회 시작시간
     * @param {string} endDate 조회 종료시간
     * @param {string} [page] 페이지, 없으면 디폴트 1
     * @param {string} [limit] 페이지당 개수, 없으면 디폴트 20
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TroubleShootingApi
     */
    public getTroubleShootingHistory(turbineId: number, startDate: string, endDate: string, page?: string, limit?: string, options?: AxiosRequestConfig) {
        return TroubleShootingApiFp(this.configuration).getTroubleShootingHistory(turbineId, startDate, endDate, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TurbineSelectionApi - axios parameter creator
 * @export
 */
export const TurbineSelectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 선택 가능한 터빈 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTurbineSelect: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/turbines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TurbineSelectionApi - functional programming interface
 * @export
 */
export const TurbineSelectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TurbineSelectionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 선택 가능한 터빈 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTurbineSelect(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TurbineSelection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTurbineSelect(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TurbineSelectionApi - factory interface
 * @export
 */
export const TurbineSelectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TurbineSelectionApiFp(configuration)
    return {
        /**
         * 
         * @summary 선택 가능한 터빈 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTurbineSelect(options?: any): AxiosPromise<TurbineSelection> {
            return localVarFp.getTurbineSelect(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TurbineSelectionApi - object-oriented interface
 * @export
 * @class TurbineSelectionApi
 * @extends {BaseAPI}
 */
export class TurbineSelectionApi extends BaseAPI {
    /**
     * 
     * @summary 선택 가능한 터빈 목록 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TurbineSelectionApi
     */
    public getTurbineSelect(options?: AxiosRequestConfig) {
        return TurbineSelectionApiFp(this.configuration).getTurbineSelect(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 사용자 정보 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 사용자 정보 등록
         * @param {AddUser} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser: async (payload: AddUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postUser', 'payload', payload)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 사용자 정보 수정
         * @param {UserInfo} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUser: async (payload: UserInfo, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('putUser', 'payload', payload)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 사용자 권한 수정
         * @param {string} userId 
         * @param {UserAuthority} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserAuthority: async (userId: string, payload: UserAuthority, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('putUserAuthority', 'userId', userId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('putUserAuthority', 'payload', payload)
            const localVarPath = `/users/{user_id}/authority`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 사용자 정보 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 사용자 정보 등록
         * @param {AddUser} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUser(payload: AddUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUser(payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 사용자 정보 수정
         * @param {UserInfo} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUser(payload: UserInfo, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUser(payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 사용자 권한 수정
         * @param {string} userId 
         * @param {UserAuthority} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserAuthority(userId: string, payload: UserAuthority, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserAuthority(userId, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary 사용자 정보 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): AxiosPromise<Array<UserInfo>> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 사용자 정보 등록
         * @param {AddUser} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser(payload: AddUser, options?: any): AxiosPromise<void> {
            return localVarFp.postUser(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 사용자 정보 수정
         * @param {UserInfo} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUser(payload: UserInfo, options?: any): AxiosPromise<void> {
            return localVarFp.putUser(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 사용자 권한 수정
         * @param {string} userId 
         * @param {UserAuthority} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserAuthority(userId: string, payload: UserAuthority, options?: any): AxiosPromise<void> {
            return localVarFp.putUserAuthority(userId, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary 사용자 정보 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 사용자 정보 등록
     * @param {AddUser} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public postUser(payload: AddUser, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).postUser(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 사용자 정보 수정
     * @param {UserInfo} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public putUser(payload: UserInfo, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).putUser(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 사용자 권한 수정
     * @param {string} userId 
     * @param {UserAuthority} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public putUserAuthority(userId: string, payload: UserAuthority, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).putUserAuthority(userId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserAnomalyApi - axios parameter creator
 * @export
 */
export const UserAnomalyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 사용자 지정 이상 감지 내역 조회
         * @param {number} turbineId 
         * @param {string} [userId] 사용자 아이디
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAnomaly: async (turbineId: number, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getUserAnomaly', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/user-orbit-threshold`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 사용자 orbit threshold 설정
         * @param {number} turbineId 
         * @param {UserOrbitThreshold} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserAnomaly: async (turbineId: number, payload: UserOrbitThreshold, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('postUserAnomaly', 'turbineId', turbineId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postUserAnomaly', 'payload', payload)
            const localVarPath = `/turbines/{turbine_id}/user-orbit-threshold`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserAnomalyApi - functional programming interface
 * @export
 */
export const UserAnomalyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserAnomalyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 사용자 지정 이상 감지 내역 조회
         * @param {number} turbineId 
         * @param {string} [userId] 사용자 아이디
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAnomaly(turbineId: number, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAnomalyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAnomaly(turbineId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 사용자 orbit threshold 설정
         * @param {number} turbineId 
         * @param {UserOrbitThreshold} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserAnomaly(turbineId: number, payload: UserOrbitThreshold, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOrbitThreshold>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserAnomaly(turbineId, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserAnomalyApi - factory interface
 * @export
 */
export const UserAnomalyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserAnomalyApiFp(configuration)
    return {
        /**
         * 
         * @summary 사용자 지정 이상 감지 내역 조회
         * @param {number} turbineId 
         * @param {string} [userId] 사용자 아이디
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAnomaly(turbineId: number, userId?: string, options?: any): AxiosPromise<UserAnomalyList> {
            return localVarFp.getUserAnomaly(turbineId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 사용자 orbit threshold 설정
         * @param {number} turbineId 
         * @param {UserOrbitThreshold} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserAnomaly(turbineId: number, payload: UserOrbitThreshold, options?: any): AxiosPromise<UserOrbitThreshold> {
            return localVarFp.postUserAnomaly(turbineId, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserAnomalyApi - object-oriented interface
 * @export
 * @class UserAnomalyApi
 * @extends {BaseAPI}
 */
export class UserAnomalyApi extends BaseAPI {
    /**
     * 
     * @summary 사용자 지정 이상 감지 내역 조회
     * @param {number} turbineId 
     * @param {string} [userId] 사용자 아이디
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAnomalyApi
     */
    public getUserAnomaly(turbineId: number, userId?: string, options?: AxiosRequestConfig) {
        return UserAnomalyApiFp(this.configuration).getUserAnomaly(turbineId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 사용자 orbit threshold 설정
     * @param {number} turbineId 
     * @param {UserOrbitThreshold} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAnomalyApi
     */
    public postUserAnomaly(turbineId: number, payload: UserOrbitThreshold, options?: AxiosRequestConfig) {
        return UserAnomalyApiFp(this.configuration).postUserAnomaly(turbineId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserEventApi - axios parameter creator
 * @export
 */
export const UserEventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 사용자 이벤트 삭제
         * @param {number} turbineId 
         * @param {number} userEventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserEvent: async (turbineId: number, userEventId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('deleteUserEvent', 'turbineId', turbineId)
            // verify required parameter 'userEventId' is not null or undefined
            assertParamExists('deleteUserEvent', 'userEventId', userEventId)
            const localVarPath = `/turbines/{turbine_id}/user-events/{user_event_id}`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)))
                .replace(`{${"user_event_id"}}`, encodeURIComponent(String(userEventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 사용자 이벤트 목록 조회
         * @param {number} turbineId 
         * @param {string} [userId] 유저 아이디, 토큰 인증을 꺼놓은 관계로 임시로 받음 (중요)
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {string} [page] 페이지, 없으면 전체목록 조회
         * @param {string} [limit] 페이지당 개수, 없으면 전체목록 조회
         * @param {string} [searchKeyword] 검색어
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventLookup: async (turbineId: number, userId?: string, startDate?: string, endDate?: string, page?: string, limit?: string, searchKeyword?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getUserEventLookup', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/user-events`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchKeyword !== undefined) {
                localVarQueryParameter['search_keyword'] = searchKeyword;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 사용자 이벤트 등록
         * @param {number} turbineId 
         * @param {UserEventBody} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserEventLookup: async (turbineId: number, payload: UserEventBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('postUserEventLookup', 'turbineId', turbineId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postUserEventLookup', 'payload', payload)
            const localVarPath = `/turbines/{turbine_id}/user-events`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 터빈 유저 이벤트 설정
         * @param {number} turbineId 
         * @param {UserEventBody} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserTurbineSetting: async (turbineId: number, payload: UserEventBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('postUserTurbineSetting', 'turbineId', turbineId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postUserTurbineSetting', 'payload', payload)
            const localVarPath = `/turbines/{turbine_id}/turbine-setting`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 사용자 이벤트 수정
         * @param {number} turbineId 
         * @param {number} userEventId 
         * @param {UserEventBody} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserEvent: async (turbineId: number, userEventId: number, payload: UserEventBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('putUserEvent', 'turbineId', turbineId)
            // verify required parameter 'userEventId' is not null or undefined
            assertParamExists('putUserEvent', 'userEventId', userEventId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('putUserEvent', 'payload', payload)
            const localVarPath = `/turbines/{turbine_id}/user-events/{user_event_id}`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)))
                .replace(`{${"user_event_id"}}`, encodeURIComponent(String(userEventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserEventApi - functional programming interface
 * @export
 */
export const UserEventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserEventApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 사용자 이벤트 삭제
         * @param {number} turbineId 
         * @param {number} userEventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserEvent(turbineId: number, userEventId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserEvent(turbineId, userEventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 사용자 이벤트 목록 조회
         * @param {number} turbineId 
         * @param {string} [userId] 유저 아이디, 토큰 인증을 꺼놓은 관계로 임시로 받음 (중요)
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {string} [page] 페이지, 없으면 전체목록 조회
         * @param {string} [limit] 페이지당 개수, 없으면 전체목록 조회
         * @param {string} [searchKeyword] 검색어
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserEventLookup(turbineId: number, userId?: string, startDate?: string, endDate?: string, page?: string, limit?: string, searchKeyword?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEventResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEventLookup(turbineId, userId, startDate, endDate, page, limit, searchKeyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 사용자 이벤트 등록
         * @param {number} turbineId 
         * @param {UserEventBody} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserEventLookup(turbineId: number, payload: UserEventBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserEventLookup(turbineId, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 터빈 유저 이벤트 설정
         * @param {number} turbineId 
         * @param {UserEventBody} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserTurbineSetting(turbineId: number, payload: UserEventBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserTurbineSetting(turbineId, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 사용자 이벤트 수정
         * @param {number} turbineId 
         * @param {number} userEventId 
         * @param {UserEventBody} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserEvent(turbineId: number, userEventId: number, payload: UserEventBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserEvent(turbineId, userEventId, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserEventApi - factory interface
 * @export
 */
export const UserEventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserEventApiFp(configuration)
    return {
        /**
         * 
         * @summary 사용자 이벤트 삭제
         * @param {number} turbineId 
         * @param {number} userEventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserEvent(turbineId: number, userEventId: number, options?: any): AxiosPromise<DeleteSuccess> {
            return localVarFp.deleteUserEvent(turbineId, userEventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 사용자 이벤트 목록 조회
         * @param {number} turbineId 
         * @param {string} [userId] 유저 아이디, 토큰 인증을 꺼놓은 관계로 임시로 받음 (중요)
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {string} [page] 페이지, 없으면 전체목록 조회
         * @param {string} [limit] 페이지당 개수, 없으면 전체목록 조회
         * @param {string} [searchKeyword] 검색어
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventLookup(turbineId: number, userId?: string, startDate?: string, endDate?: string, page?: string, limit?: string, searchKeyword?: string, options?: any): AxiosPromise<UserEventResult> {
            return localVarFp.getUserEventLookup(turbineId, userId, startDate, endDate, page, limit, searchKeyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 사용자 이벤트 등록
         * @param {number} turbineId 
         * @param {UserEventBody} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserEventLookup(turbineId: number, payload: UserEventBody, options?: any): AxiosPromise<UserEventList> {
            return localVarFp.postUserEventLookup(turbineId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 터빈 유저 이벤트 설정
         * @param {number} turbineId 
         * @param {UserEventBody} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserTurbineSetting(turbineId: number, payload: UserEventBody, options?: any): AxiosPromise<DeleteSuccess> {
            return localVarFp.postUserTurbineSetting(turbineId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 사용자 이벤트 수정
         * @param {number} turbineId 
         * @param {number} userEventId 
         * @param {UserEventBody} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserEvent(turbineId: number, userEventId: number, payload: UserEventBody, options?: any): AxiosPromise<UserEventList> {
            return localVarFp.putUserEvent(turbineId, userEventId, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserEventApi - object-oriented interface
 * @export
 * @class UserEventApi
 * @extends {BaseAPI}
 */
export class UserEventApi extends BaseAPI {
    /**
     * 
     * @summary 사용자 이벤트 삭제
     * @param {number} turbineId 
     * @param {number} userEventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEventApi
     */
    public deleteUserEvent(turbineId: number, userEventId: number, options?: AxiosRequestConfig) {
        return UserEventApiFp(this.configuration).deleteUserEvent(turbineId, userEventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 사용자 이벤트 목록 조회
     * @param {number} turbineId 
     * @param {string} [userId] 유저 아이디, 토큰 인증을 꺼놓은 관계로 임시로 받음 (중요)
     * @param {string} [startDate] 조회 시작시간
     * @param {string} [endDate] 조회 종료시간
     * @param {string} [page] 페이지, 없으면 전체목록 조회
     * @param {string} [limit] 페이지당 개수, 없으면 전체목록 조회
     * @param {string} [searchKeyword] 검색어
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEventApi
     */
    public getUserEventLookup(turbineId: number, userId?: string, startDate?: string, endDate?: string, page?: string, limit?: string, searchKeyword?: string, options?: AxiosRequestConfig) {
        return UserEventApiFp(this.configuration).getUserEventLookup(turbineId, userId, startDate, endDate, page, limit, searchKeyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 사용자 이벤트 등록
     * @param {number} turbineId 
     * @param {UserEventBody} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEventApi
     */
    public postUserEventLookup(turbineId: number, payload: UserEventBody, options?: AxiosRequestConfig) {
        return UserEventApiFp(this.configuration).postUserEventLookup(turbineId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 터빈 유저 이벤트 설정
     * @param {number} turbineId 
     * @param {UserEventBody} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEventApi
     */
    public postUserTurbineSetting(turbineId: number, payload: UserEventBody, options?: AxiosRequestConfig) {
        return UserEventApiFp(this.configuration).postUserTurbineSetting(turbineId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 사용자 이벤트 수정
     * @param {number} turbineId 
     * @param {number} userEventId 
     * @param {UserEventBody} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEventApi
     */
    public putUserEvent(turbineId: number, userEventId: number, payload: UserEventBody, options?: AxiosRequestConfig) {
        return UserEventApiFp(this.configuration).putUserEvent(turbineId, userEventId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VibrationDigitalTwinApi - axios parameter creator
 * @export
 */
export const VibrationDigitalTwinApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 베어링 진동관련 데이터 - Eccentricity 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVibrationDigitalTwin: async (turbineId: number, acqTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getVibrationDigitalTwin', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/vibration-twin/eccentricity`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acqTime !== undefined) {
                localVarQueryParameter['acq_time'] = acqTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 베어링 진동 데이터 - FFT 그래프 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVibrationDigitalTwinFft: async (turbineId: number, acqTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getVibrationDigitalTwinFft', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/vibration-twin/fft`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acqTime !== undefined) {
                localVarQueryParameter['acq_time'] = acqTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 베어링 진동관련 데이터 - 폴라 그래프 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVibrationDigitalTwinPolar: async (turbineId: number, acqTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getVibrationDigitalTwinPolar', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/vibration-twin/bode-polar`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acqTime !== undefined) {
                localVarQueryParameter['acq_time'] = acqTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 진동 디지털 트윈: 기간 조회 API
         * @param {number} turbineId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVibrationPredictOverviewSearch: async (turbineId: number, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getVibrationPredictOverviewSearch', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/vibration-twin/overview`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VibrationDigitalTwinApi - functional programming interface
 * @export
 */
export const VibrationDigitalTwinApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VibrationDigitalTwinApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 베어링 진동관련 데이터 - Eccentricity 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVibrationDigitalTwin(turbineId: number, acqTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VibrationDigitalTwinInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVibrationDigitalTwin(turbineId, acqTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 베어링 진동 데이터 - FFT 그래프 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVibrationDigitalTwinFft(turbineId: number, acqTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGraphFft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVibrationDigitalTwinFft(turbineId, acqTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 베어링 진동관련 데이터 - 폴라 그래프 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVibrationDigitalTwinPolar(turbineId: number, acqTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGraphBodePolar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVibrationDigitalTwinPolar(turbineId, acqTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 진동 디지털 트윈: 기간 조회 API
         * @param {number} turbineId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVibrationPredictOverviewSearch(turbineId: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchDataSlider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVibrationPredictOverviewSearch(turbineId, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VibrationDigitalTwinApi - factory interface
 * @export
 */
export const VibrationDigitalTwinApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VibrationDigitalTwinApiFp(configuration)
    return {
        /**
         * 
         * @summary 베어링 진동관련 데이터 - Eccentricity 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVibrationDigitalTwin(turbineId: number, acqTime?: string, options?: any): AxiosPromise<Array<VibrationDigitalTwinInfo>> {
            return localVarFp.getVibrationDigitalTwin(turbineId, acqTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 베어링 진동 데이터 - FFT 그래프 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVibrationDigitalTwinFft(turbineId: number, acqTime?: string, options?: any): AxiosPromise<DataGraphFft> {
            return localVarFp.getVibrationDigitalTwinFft(turbineId, acqTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 베어링 진동관련 데이터 - 폴라 그래프 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 특정 조회 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVibrationDigitalTwinPolar(turbineId: number, acqTime?: string, options?: any): AxiosPromise<DataGraphBodePolar> {
            return localVarFp.getVibrationDigitalTwinPolar(turbineId, acqTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 진동 디지털 트윈: 기간 조회 API
         * @param {number} turbineId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVibrationPredictOverviewSearch(turbineId: number, startDate?: string, endDate?: string, options?: any): AxiosPromise<SearchDataSlider> {
            return localVarFp.getVibrationPredictOverviewSearch(turbineId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VibrationDigitalTwinApi - object-oriented interface
 * @export
 * @class VibrationDigitalTwinApi
 * @extends {BaseAPI}
 */
export class VibrationDigitalTwinApi extends BaseAPI {
    /**
     * 
     * @summary 베어링 진동관련 데이터 - Eccentricity 조회
     * @param {number} turbineId 
     * @param {string} [acqTime] 특정 조회 시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VibrationDigitalTwinApi
     */
    public getVibrationDigitalTwin(turbineId: number, acqTime?: string, options?: AxiosRequestConfig) {
        return VibrationDigitalTwinApiFp(this.configuration).getVibrationDigitalTwin(turbineId, acqTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 베어링 진동 데이터 - FFT 그래프 조회
     * @param {number} turbineId 
     * @param {string} [acqTime] 특정 조회 시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VibrationDigitalTwinApi
     */
    public getVibrationDigitalTwinFft(turbineId: number, acqTime?: string, options?: AxiosRequestConfig) {
        return VibrationDigitalTwinApiFp(this.configuration).getVibrationDigitalTwinFft(turbineId, acqTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 베어링 진동관련 데이터 - 폴라 그래프 조회
     * @param {number} turbineId 
     * @param {string} [acqTime] 특정 조회 시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VibrationDigitalTwinApi
     */
    public getVibrationDigitalTwinPolar(turbineId: number, acqTime?: string, options?: AxiosRequestConfig) {
        return VibrationDigitalTwinApiFp(this.configuration).getVibrationDigitalTwinPolar(turbineId, acqTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 진동 디지털 트윈: 기간 조회 API
     * @param {number} turbineId 
     * @param {string} [startDate] 조회 시작시간
     * @param {string} [endDate] 조회 종료시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VibrationDigitalTwinApi
     */
    public getVibrationPredictOverviewSearch(turbineId: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return VibrationDigitalTwinApiFp(this.configuration).getVibrationPredictOverviewSearch(turbineId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VibrationPredictionApi - axios parameter creator
 * @export
 */
export const VibrationPredictionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 단기 진동 예측 각 베어링별 데이터 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 조회 시점 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVibrationPredict: async (turbineId: number, acqTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getVibrationPredict', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/vibration-predict/bearings`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acqTime !== undefined) {
                localVarQueryParameter['acq_time'] = acqTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 각 베어링별 예측 모델 데이터 조회
         * @param {number} turbineId 
         * @param {number} bearingId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVibrationPredictModels: async (turbineId: number, bearingId: number, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getVibrationPredictModels', 'turbineId', turbineId)
            // verify required parameter 'bearingId' is not null or undefined
            assertParamExists('getVibrationPredictModels', 'bearingId', bearingId)
            const localVarPath = `/turbines/{turbine_id}/vibration-predict/bearings/{bearing_id}`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)))
                .replace(`{${"bearing_id"}}`, encodeURIComponent(String(bearingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 단기 진동 예측: 기간 조회 API
         * @param {number} turbineId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVibrationPredictOverviewSearch: async (turbineId: number, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'turbineId' is not null or undefined
            assertParamExists('getVibrationPredictOverviewSearch', 'turbineId', turbineId)
            const localVarPath = `/turbines/{turbine_id}/vibration-predict/overview`
                .replace(`{${"turbine_id"}}`, encodeURIComponent(String(turbineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VibrationPredictionApi - functional programming interface
 * @export
 */
export const VibrationPredictionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VibrationPredictionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 단기 진동 예측 각 베어링별 데이터 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 조회 시점 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVibrationPredict(turbineId: number, acqTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VibPredDashboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVibrationPredict(turbineId, acqTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 각 베어링별 예측 모델 데이터 조회
         * @param {number} turbineId 
         * @param {number} bearingId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVibrationPredictModels(turbineId: number, bearingId: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VibPredModelResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVibrationPredictModels(turbineId, bearingId, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 단기 진동 예측: 기간 조회 API
         * @param {number} turbineId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVibrationPredictOverviewSearch(turbineId: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchDataSlider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVibrationPredictOverviewSearch(turbineId, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VibrationPredictionApi - factory interface
 * @export
 */
export const VibrationPredictionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VibrationPredictionApiFp(configuration)
    return {
        /**
         * 
         * @summary 단기 진동 예측 각 베어링별 데이터 조회
         * @param {number} turbineId 
         * @param {string} [acqTime] 조회 시점 시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVibrationPredict(turbineId: number, acqTime?: string, options?: any): AxiosPromise<VibPredDashboard> {
            return localVarFp.getVibrationPredict(turbineId, acqTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 각 베어링별 예측 모델 데이터 조회
         * @param {number} turbineId 
         * @param {number} bearingId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVibrationPredictModels(turbineId: number, bearingId: number, startDate?: string, endDate?: string, options?: any): AxiosPromise<VibPredModelResp> {
            return localVarFp.getVibrationPredictModels(turbineId, bearingId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 단기 진동 예측: 기간 조회 API
         * @param {number} turbineId 
         * @param {string} [startDate] 조회 시작시간
         * @param {string} [endDate] 조회 종료시간
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVibrationPredictOverviewSearch(turbineId: number, startDate?: string, endDate?: string, options?: any): AxiosPromise<SearchDataSlider> {
            return localVarFp.getVibrationPredictOverviewSearch(turbineId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VibrationPredictionApi - object-oriented interface
 * @export
 * @class VibrationPredictionApi
 * @extends {BaseAPI}
 */
export class VibrationPredictionApi extends BaseAPI {
    /**
     * 
     * @summary 단기 진동 예측 각 베어링별 데이터 조회
     * @param {number} turbineId 
     * @param {string} [acqTime] 조회 시점 시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VibrationPredictionApi
     */
    public getVibrationPredict(turbineId: number, acqTime?: string, options?: AxiosRequestConfig) {
        return VibrationPredictionApiFp(this.configuration).getVibrationPredict(turbineId, acqTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 각 베어링별 예측 모델 데이터 조회
     * @param {number} turbineId 
     * @param {number} bearingId 
     * @param {string} [startDate] 조회 시작시간
     * @param {string} [endDate] 조회 종료시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VibrationPredictionApi
     */
    public getVibrationPredictModels(turbineId: number, bearingId: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return VibrationPredictionApiFp(this.configuration).getVibrationPredictModels(turbineId, bearingId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 단기 진동 예측: 기간 조회 API
     * @param {number} turbineId 
     * @param {string} [startDate] 조회 시작시간
     * @param {string} [endDate] 조회 종료시간
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VibrationPredictionApi
     */
    public getVibrationPredictOverviewSearch(turbineId: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return VibrationPredictionApiFp(this.configuration).getVibrationPredictOverviewSearch(turbineId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
}


